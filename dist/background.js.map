{"version":3,"file":"background.js","sources":["webpack://site-blocker/./src/utils/blockedSites.ts","webpack://site-blocker/./src/utils/promisify.ts","webpack://site-blocker/./src/utils/types.ts","webpack://site-blocker/webpack/bootstrap","webpack://site-blocker/webpack/runtime/define property getters","webpack://site-blocker/webpack/runtime/hasOwnProperty shorthand","webpack://site-blocker/webpack/runtime/make namespace object","webpack://site-blocker/./src/background.ts"],"sourcesContent":["// const blockedSites = [\n//   /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{0,256}imgur.[-a-zA-Z0-9@:%._\\+~#=]{1,256}(\\/)?/,\n//   /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{0,256}youtube.[-a-zA-Z0-9@:%._\\+~#=]{1,256}(\\/)?/,\n//   /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{0,256}reddit.[-a-zA-Z0-9@:%._\\+~#=]{1,256}(\\/)?/,\n//   /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{0,256}messenger.[-a-zA-Z0-9@:%._\\+~#=]{1,256}(\\/)?/,\n//   /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{0,256}linkedin.[-a-zA-Z0-9@:%._\\+~#=]{1,256}(\\/)?/,\n//   /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{0,256}news.google.[-a-zA-Z0-9@:%._\\+~#=]{1,256}(\\/)?/,\n// ];\n\nconst sites = [\n  \"imgur\",\n  \"youtube\",\n  \"reddit\",\n  \"messenger\",\n  \"linkedin\",\n  \"news.google\",\n];\n\nconst blockedSites = sites.map((site) => {\n  return new RegExp(\n    `https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{0,256}${site}.[-a-zA-Z0-9@:%._\\+~#=]{1,256}(\\/)?`\n  );\n});\n\nexport default blockedSites;\n","import {\n  BackendState,\n  // isBlockingTimerId,\n  // isBlockingTimestamp,\n  // isIsBlocking,\n} from \"@utils/types\";\n\ntype Properties<T> = keyof T;\n\nexport function chromeStorageGet(key: Properties<BackendState>) {\n  return new Promise<BackendState[typeof key]>((resolve, reject) => {\n    chrome.storage.local.get(key, (uncast) => {\n      if (chrome.runtime.lastError) return reject(chrome.runtime.lastError);\n\n      // have to cast somewhere?\n      const cast = uncast as BackendState;\n      const data = cast[key];\n      resolve(data);\n    });\n  });\n}\n","interface IsBlockingRequest {\n  type: \"REQ_IS_BLOCKING_STATUS\";\n}\n\ninterface IsBlockingResponse {\n  type: \"IS_BLOCKING_STATUS\";\n  isBlocking: boolean;\n}\n\ninterface IsBlockingToggle {\n  type: \"TOGGLE_IS_BLOCKING\";\n  isBlocking: boolean;\n}\n\ninterface BlockingTimestampRequest {\n  type: \"REQ_BLOCKING_TIMESTAMP\";\n}\n\ninterface BlockingTimestampResponse {\n  type: \"BLOCKING_TIMESTAMP\";\n  timestamp: string | null;\n}\n\ninterface SetBlockingTimeStamp {\n  type: \"SET_BLOCKING_TIMESTAMP\";\n  timestamp: string | null;\n}\n\ninterface BackendState {\n  isBlocking: boolean;\n  blockingTimestamp: string | null;\n  blockingTimerId: number | null;\n}\n\nexport type Message =\n  | IsBlockingRequest\n  | IsBlockingResponse\n  | IsBlockingToggle\n  | BlockingTimestampRequest\n  | BlockingTimestampResponse\n  | SetBlockingTimeStamp;\n\nexport type { BackendState };\n\nexport function isIsBlocking(isBlocking: any): isBlocking is boolean {\n  return typeof isBlocking === \"boolean\";\n}\n\nexport function isBlockingTimestamp(\n  blockingTimestamp: any\n): blockingTimestamp is string | null {\n  return (\n    // blockingTimestamp instanceof Date ||\n    blockingTimestamp === null || typeof blockingTimestamp === \"string\"\n  );\n}\n\nexport function isBlockingTimerId(\n  blockingTimerId: any\n): blockingTimerId is number | null {\n  return typeof blockingTimerId === \"number\" || blockingTimerId === null;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import blockedSites from \"./utils/blockedSites\";\nimport {\n  Message,\n  isIsBlocking,\n  isBlockingTimerId,\n  isBlockingTimestamp,\n} from \"./utils/types\";\nimport { chromeStorageGet } from \"./utils/promisify\";\n\n(async function init() {\n  // should always be null, since on unmount it's set to null anyway\n  chrome.storage.local.set({ blockingTimerId: null });\n\n  const isBlocking = await chromeStorageGet(\"isBlocking\");\n  if (isBlocking === undefined) {\n    chrome.storage.local.set({ isBlocking: true });\n  }\n\n  // first check if there's a timer ongoing\n  const blockingTimestamp = await chromeStorageGet(\"blockingTimestamp\");\n  if (!isBlockingTimestamp(blockingTimestamp)) {\n    throw new TypeError(\n      `expected blockingTimestamp, got ${typeof blockingTimestamp}`\n    );\n  }\n\n  if (!blockingTimestamp) {\n    setBlockingTimestamp(null);\n    return;\n  }\n\n  // negative timestamp, reset\n  if (new Date(blockingTimestamp).getTime() - Date.now() < 0) {\n    setBlockingTimestamp(null);\n    return;\n  }\n\n  // ongoing timer\n  if (new Date(blockingTimestamp).getTime() - Date.now() >= 0) {\n    const blockingTimerId = setTimeout(() => {\n      console.log(\"BACKEND: in set timeout, setting to null\");\n      setBlockingTimestamp(null);\n      setIsBlocking(true);\n      setBlockingTimerId(null);\n    }, new Date(blockingTimestamp).getTime() - Date.now()) as unknown as number;\n\n    setBlockingTimerId(blockingTimerId);\n  }\n})();\n\n// TODO doesn't really seem to have helped the delay?\n// chrome.tabs.onCreated.addListener(async (tab) => {\n//   if (!tab.pendingUrl) return;\n//   if (!tab.id) return;\n//   const isBlocking = Boolean(await chromeStorageGet(\"isBlocking\"));\n//   if (!isIsBlocking(isBlocking)) return;\n\n//   for (const regex of blockedSites) {\n//     if (regex.test(tab.pendingUrl)) {\n//       chrome.tabs.remove(tab.id);\n//       break;\n//     }\n//   }\n// });\n\nchrome.tabs.onUpdated.addListener(async (tabId, _, tab) => {\n  if (!tab.url) return;\n  const isBlocking = !!(await chromeStorageGet(\"isBlocking\"));\n  if (!isIsBlocking(isBlocking)) {\n    throw new TypeError(`expected isBlocking, got ${typeof isBlocking}`);\n  }\n\n  if (!isBlocking) return;\n\n  // want to run sync, don't want to bother with forEach\n  for (const regex of blockedSites) {\n    if (regex.test(tab.url)) {\n      chrome.tabs.remove(tabId, () => {\n        console.log(\"BACKEND: removed tab\", { tabId, url: tab.url });\n      });\n      break;\n    }\n  }\n});\n\n// on unmount\nchrome.runtime.onSuspend.addListener(async () => {\n  const blockingTimerId = await chromeStorageGet(\"blockingTimerId\");\n  if (!isBlockingTimerId(blockingTimerId)) {\n    throw new TypeError(\n      `expected blockingTimerId, got ${typeof blockingTimerId}`\n    );\n  }\n\n  // if there's a current timer, cancel it, but keep the timestamp\n  if (blockingTimerId) {\n    clearTimeout(blockingTimerId);\n  }\n  setBlockingTimerId(null);\n});\n\nchrome.runtime.onMessage.addListener(async (message: Message) => {\n  switch (message.type) {\n    case \"REQ_IS_BLOCKING_STATUS\":\n      const isBlocking = await chromeStorageGet(\"isBlocking\");\n      console.log(\"BACKEND: received request for blocking status\", {\n        isBlocking,\n      });\n\n      if (!isIsBlocking(isBlocking)) {\n        throw new TypeError(`expected isBlocking, got ${typeof isBlocking}`);\n      }\n      sendIsBlockingStatus(isBlocking);\n\n      break;\n\n    case \"TOGGLE_IS_BLOCKING\":\n      setIsBlocking(message.isBlocking);\n      console.log(\"BACKEND: received request to toggle isBlocking status\", {\n        isBlocking: message.isBlocking,\n      });\n      break;\n\n    case \"REQ_BLOCKING_TIMESTAMP\":\n      const blockingTimestamp = await chromeStorageGet(\"blockingTimestamp\");\n      console.log(\"BACKEND: received request for blocking timestamp\", {\n        blockingTimestamp,\n      });\n\n      if (!isBlockingTimestamp(blockingTimestamp)) {\n        throw new TypeError(\n          `expected isBlockingTimestamp, got ${typeof blockingTimestamp}`\n        );\n      }\n      sendBlockingTimestamp(blockingTimestamp);\n      break;\n\n    case \"SET_BLOCKING_TIMESTAMP\":\n      console.log(\"BACKEND: received request to set blocking timestamp\", {\n        timestamp: message.timestamp,\n      });\n\n      // if the message sent has a null timestamp, i.e. cancel the current timer\n      if (!message.timestamp) {\n        console.log(\"INSIDE if statement for null timestamp\");\n        setBlockingTimestamp(message.timestamp);\n\n        const blockingTimerId = await chromeStorageGet(\"blockingTimerId\");\n        if (!isBlockingTimerId(blockingTimerId)) {\n          throw new TypeError(\n            `expected blockingTimerId, got ${typeof blockingTimerId}`\n          );\n        }\n\n        // if there's a current timer, cancel it\n        if (blockingTimerId) {\n          clearTimeout(blockingTimerId);\n        }\n        setBlockingTimerId(null);\n\n        return;\n      }\n      console.log(\"INSIDE: after if statement for null timestamp\");\n\n      // if the message sent a real timestamp\n      setBlockingTimestamp(message.timestamp);\n\n      const blockingTimerId = setTimeout(() => {\n        // once timer finishes\n        console.log(\"BACKEND: in set timeout, setting to null\");\n        setBlockingTimestamp(null);\n        setIsBlocking(true);\n        setBlockingTimerId(null);\n      }, new Date(message.timestamp).getTime() - Date.now()) as unknown as number;\n\n      setBlockingTimerId(blockingTimerId);\n      break;\n\n    default:\n      break;\n  }\n});\n\n// isBlocking helpers\nfunction sendIsBlockingStatus(isBlocking: boolean) {\n  const message: Message = { type: \"IS_BLOCKING_STATUS\", isBlocking };\n  chrome.runtime.sendMessage(message);\n}\n\nfunction setIsBlocking(isBlocking: boolean): void {\n  chrome.storage.local.set({ isBlocking });\n  sendIsBlockingStatus(isBlocking);\n}\n\n// blockingTimestamp helpers\nfunction sendBlockingTimestamp(blockingTimestamp: string | null) {\n  const message: Message = {\n    type: \"BLOCKING_TIMESTAMP\",\n    timestamp: blockingTimestamp,\n  };\n  chrome.runtime.sendMessage(message);\n}\n\nfunction setBlockingTimestamp(blockingTimestamp: string | null): void {\n  chrome.storage.local.set({ blockingTimestamp });\n  sendBlockingTimestamp(blockingTimestamp);\n}\n\n// blockingTimerId helpers\nfunction setBlockingTimerId(blockingTimerId: number | null): void {\n  chrome.storage.local.set({ blockingTimerId });\n}\n"],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;A;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;ACsBA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;A;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AAMA;AAEA;;;;;;AACA;AACA;AAEA;;AAAA;AACA;AACA;AACA;AAGA;;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AACA;AAAA;AACA;;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AAEA;AACA;;;;AACA;;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;;;;AACA;AAEA;;;;;AACA;;AACA;AAaA;AAOA;AAcA;;;AAjCA;;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AACA;AAGA;;AAAA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;A","sourceRoot":""}