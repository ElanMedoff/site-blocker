{"version":3,"file":"background.js","sources":["webpack://site-blocker/./src/utils/blockedSites.ts","webpack://site-blocker/./src/utils/promisify.ts","webpack://site-blocker/./src/utils/types.ts","webpack://site-blocker/webpack/bootstrap","webpack://site-blocker/webpack/runtime/define property getters","webpack://site-blocker/webpack/runtime/hasOwnProperty shorthand","webpack://site-blocker/webpack/runtime/make namespace object","webpack://site-blocker/./src/background.ts"],"sourcesContent":["const sites = [\n  \"imgur\",\n  \"youtube\",\n  \"reddit\",\n  \"messenger\",\n  \"linkedin\",\n  \"news.google\",\n  \"facebook\",\n];\n\nconst blockedSites = sites.map((site) => {\n  return new RegExp(\n    `https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{0,256}${site}.[-a-zA-Z0-9@:%._\\+~#=]{1,256}(\\/)?`\n  );\n});\n\nconst exerciseExceptions = [\n  // warmup\n  \"https://www.youtube.com/watch?v=2L2lnxIcNmo\",\n  // cooldown\n  \"https://www.youtube.com/watch?v=uW3-Ue07H0M\",\n];\n\nconst ocarinaExceptions = [\"https://www.youtube.com/watch?v=urxk4mveLCw\"];\n\nconst videoExceptions = ([] as string[])\n  .concat(exerciseExceptions)\n  .concat(ocarinaExceptions);\n\nconst playlistExceptions = [\n  // major\n  \"list=PL4vyWz4g-OOEpsJbV21QuTVv9LO2miP5G\",\n  // minor\n  \"list=PL4vyWz4g-OOFr_xmNKpSRrbntBvXImKjw\",\n  \"list=PL6FhCd_HO_ACxgtgGlFP8mgxj2EbAaPW6\",\n  \"list=PL4V9GrlFUVDG95X3zny9CEvLFnkmfJHVP\",\n  \"list=PL4V9GrlFUVDGGOnUUCDbOuLXtNEpfCWao\",\n  \"list=PL4V9GrlFUVDHEIruoi3kkxhbCbO09JHxX\",\n];\n\nexport { blockedSites, videoExceptions, playlistExceptions };\n","import { BackendState } from \"@utils/types\";\n\ntype Properties<T> = keyof T;\n\nexport function chromeStorageGet(key: Properties<BackendState>) {\n  return new Promise<BackendState[typeof key]>((resolve, reject) => {\n    chrome.storage.local.get(key, (uncast) => {\n      if (chrome.runtime.lastError) return reject(chrome.runtime.lastError);\n\n      // have to cast somewhere?\n      const cast = uncast as BackendState;\n      const data = cast[key];\n      resolve(data);\n    });\n  });\n}\n\nexport function chromeTabsGet(tabId: number) {\n  return new Promise<boolean>((resolve, reject) => {\n    chrome.tabs.get(tabId, () => {\n      if (chrome.runtime.lastError) return reject(chrome.runtime.lastError);\n      resolve(true);\n    });\n  });\n}\n\nexport function chromeTabsRemove(tabId: number, tabUrl: string) {\n  return new Promise<void>((resolve, reject) => {\n    chrome.tabs.remove(tabId, () => {\n      if (chrome.runtime.lastError) return reject(chrome.runtime.lastError);\n      console.log(\"BACKEND: removed tab\", { tabId, tabUrl });\n      resolve();\n    });\n  });\n}\n","interface IsBlockingRequest {\n  type: \"REQ_IS_BLOCKING_STATUS\";\n}\n\ninterface IsBlockingResponse {\n  type: \"IS_BLOCKING_STATUS\";\n  isBlocking: boolean;\n}\n\ninterface IsBlockingToggle {\n  type: \"TOGGLE_IS_BLOCKING\";\n  isBlocking: boolean;\n}\n\ninterface BlockingTimestampRequest {\n  type: \"REQ_BLOCKING_TIMESTAMP\";\n}\n\ninterface BlockingTimestampResponse {\n  type: \"BLOCKING_TIMESTAMP\";\n  timestamp: string | null;\n}\n\ninterface SetBlockingTimeStamp {\n  type: \"SET_BLOCKING_TIMESTAMP\";\n  timestamp: string | null;\n}\n\ninterface BackendState {\n  isBlocking: boolean;\n  blockingTimestamp: string | null | undefined;\n  blockingTimerId: number | null | undefined;\n}\n\nexport type Message =\n  | IsBlockingRequest\n  | IsBlockingResponse\n  | IsBlockingToggle\n  | BlockingTimestampRequest\n  | BlockingTimestampResponse\n  | SetBlockingTimeStamp;\n\nexport type { BackendState };\n\nexport function isIsBlocking(isBlocking: any): isBlocking is boolean {\n  return typeof isBlocking === \"boolean\";\n}\n\nexport function isBlockingTimestamp(\n  blockingTimestamp: any\n): blockingTimestamp is string | null {\n  return blockingTimestamp === null || typeof blockingTimestamp === \"string\";\n}\n\nexport function isBlockingTimerId(\n  blockingTimerId: any\n): blockingTimerId is number | null {\n  return typeof blockingTimerId === \"number\" || blockingTimerId === null;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\n  blockedSites,\n  videoExceptions,\n  playlistExceptions,\n} from \"@utils/blockedSites\";\nimport {\n  Message,\n  isIsBlocking,\n  isBlockingTimerId,\n  isBlockingTimestamp,\n} from \"@utils/types\";\nimport {\n  chromeStorageGet,\n  chromeTabsGet,\n  chromeTabsRemove,\n} from \"@utils/promisify\";\n\n(async function init() {\n  // should always be null, since on unmount it's set to null anyway\n  chrome.storage.local.set({ blockingTimerId: null });\n\n  const isBlocking = await chromeStorageGet(\"isBlocking\");\n  if (isBlocking === undefined) {\n    chrome.storage.local.set({ isBlocking: true });\n  }\n\n  // first check if there's a timer ongoing\n  const blockingTimestamp = await chromeStorageGet(\"blockingTimestamp\");\n  if (!isBlockingTimestamp(blockingTimestamp)) {\n    throw new TypeError(\n      `expected blockingTimestamp, got ${typeof blockingTimestamp}`\n    );\n  }\n\n  if (!blockingTimestamp) {\n    setBlockingTimestamp(null);\n    return;\n  }\n\n  // negative timestamp, reset\n  if (new Date(blockingTimestamp).getTime() - Date.now() < 1000) {\n    setBlockingTimestamp(null);\n    return;\n  }\n\n  // ongoing timer\n  if (new Date(blockingTimestamp).getTime() - Date.now() >= 1000) {\n    const blockingTimerId = setTimeout(() => {\n      console.log(\"BACKEND: in set timeout, setting to null\");\n      setBlockingTimestamp(null);\n      setIsBlocking(true);\n      setBlockingTimerId(null);\n    }, new Date(blockingTimestamp).getTime() - Date.now()) as unknown as number;\n\n    setBlockingTimerId(blockingTimerId);\n  }\n})();\n\nchrome.tabs.onUpdated.addListener(async (tabId, _, tab) => {\n  // because this runs async and is fired many times one after the other, we don't know for sure\n  // that the tab will still be around by the time this cb runs, it could have been removed by an\n  // earlier cb ... I think\n  const maybeTabExists = await chromeTabsGet(tabId).catch((err) =>\n    console.log(err.message, \"get\")\n  );\n  if (!maybeTabExists) return;\n\n  if (!tab.url) return;\n  const isBlocking = !!(await chromeStorageGet(\"isBlocking\"));\n  if (!isIsBlocking(isBlocking)) {\n    throw new TypeError(`expected isBlocking, got ${typeof isBlocking}`);\n  }\n\n  if (!isBlocking) return;\n\n  // exclude exceptions\n  for (const exception of videoExceptions) {\n    if (tab.url === exception) return;\n  }\n\n  for (const exception of playlistExceptions) {\n    console.log(tab.url, tab.url.includes(exception));\n    if (tab.url.includes(exception)) return;\n  }\n\n  // want to run sync, don't want to bother with forEach\n  for (const regex of blockedSites) {\n    if (regex.test(tab.url)) {\n      // TODO\n      // still not completely sure why this catch would trigger with the check above ...\n      await chromeTabsRemove(tabId, tab.url).catch((err) =>\n        console.log(err.message, \"remove\")\n      );\n      return;\n    }\n  }\n});\n\n// on unmount\nchrome.runtime.onSuspend.addListener(async () => {\n  const blockingTimerId = await chromeStorageGet(\"blockingTimerId\");\n  if (!isBlockingTimerId(blockingTimerId)) {\n    throw new TypeError(\n      `expected blockingTimerId, got ${typeof blockingTimerId}`\n    );\n  }\n\n  // if there's a current timer, cancel it, but keep the timestamp\n  if (blockingTimerId) {\n    clearTimeout(blockingTimerId);\n  }\n  setBlockingTimerId(null);\n});\n\nchrome.runtime.onMessage.addListener(async (message: Message) => {\n  switch (message.type) {\n    case \"REQ_IS_BLOCKING_STATUS\":\n      const isBlocking = await chromeStorageGet(\"isBlocking\");\n      console.log(\"BACKEND: received request for blocking status\", {\n        isBlocking,\n      });\n\n      if (!isIsBlocking(isBlocking)) {\n        throw new TypeError(`expected isBlocking, got ${typeof isBlocking}`);\n      }\n      sendIsBlockingStatus(isBlocking);\n\n      break;\n\n    case \"TOGGLE_IS_BLOCKING\":\n      setIsBlocking(message.isBlocking);\n      console.log(\"BACKEND: received request to toggle isBlocking status\", {\n        isBlocking: message.isBlocking,\n      });\n      break;\n\n    case \"REQ_BLOCKING_TIMESTAMP\":\n      const blockingTimestamp = await chromeStorageGet(\"blockingTimestamp\");\n      console.log(\"BACKEND: received request for blocking timestamp\", {\n        blockingTimestamp,\n      });\n\n      console.log(blockingTimestamp);\n      if (blockingTimestamp === undefined) return;\n\n      if (!isBlockingTimestamp(blockingTimestamp)) {\n        throw new TypeError(\n          `expected isBlockingTimestamp, got ${typeof blockingTimestamp}`\n        );\n      }\n      sendBlockingTimestamp(blockingTimestamp);\n      break;\n\n    case \"SET_BLOCKING_TIMESTAMP\":\n      console.log(\"BACKEND: received request to set blocking timestamp\", {\n        timestamp: message.timestamp,\n      });\n\n      // if the message sent has a null timestamp, i.e. cancel the current timer\n      if (!message.timestamp) {\n        console.log(\"INSIDE if statement for null timestamp\");\n        setBlockingTimestamp(message.timestamp);\n\n        const blockingTimerId = await chromeStorageGet(\"blockingTimerId\");\n        if (!isBlockingTimerId(blockingTimerId)) {\n          throw new TypeError(\n            `expected blockingTimerId, got ${typeof blockingTimerId}`\n          );\n        }\n\n        // if there's a current timer, cancel it\n        if (blockingTimerId) {\n          clearTimeout(blockingTimerId);\n        }\n        setBlockingTimerId(null);\n\n        return;\n      }\n      console.log(\"INSIDE: after if statement for null timestamp\");\n\n      // if the message sent a real timestamp\n      setBlockingTimestamp(message.timestamp);\n\n      const blockingTimerId = setTimeout(() => {\n        // once timer finishes\n        console.log(\"BACKEND: in set timeout, setting to null\");\n        setBlockingTimestamp(null);\n        setIsBlocking(true);\n        setBlockingTimerId(null);\n      }, new Date(message.timestamp).getTime() - Date.now()) as unknown as number;\n\n      setBlockingTimerId(blockingTimerId);\n      break;\n\n    default:\n      break;\n  }\n});\n\n// isBlocking helpers\nfunction sendIsBlockingStatus(isBlocking: boolean) {\n  const message: Message = { type: \"IS_BLOCKING_STATUS\", isBlocking };\n  chrome.runtime.sendMessage(message);\n}\n\nfunction setIsBlocking(isBlocking: boolean): void {\n  chrome.storage.local.set({ isBlocking });\n  sendIsBlockingStatus(isBlocking);\n}\n\n// blockingTimestamp helpers\nfunction sendBlockingTimestamp(blockingTimestamp: string | null) {\n  const message: Message = {\n    type: \"BLOCKING_TIMESTAMP\",\n    timestamp: blockingTimestamp,\n  };\n  chrome.runtime.sendMessage(message);\n}\n\nfunction setBlockingTimestamp(blockingTimestamp: string | null): void {\n  chrome.storage.local.set({ blockingTimestamp });\n  sendBlockingTimestamp(blockingTimestamp);\n}\n\n// blockingTimerId helpers\nfunction setBlockingTimerId(blockingTimerId: number | null): void {\n  chrome.storage.local.set({ blockingTimerId });\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;A;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;ACQA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AACA;A;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAKA;AAMA;AAMA;;;;;;AACA;AACA;AAEA;;AAAA;AACA;AACA;AACA;AAGA;;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AACA;AAEA;;;;AAIA;AACA;AAAA;;AADA;AAGA;AAAA;AAEA;AAAA;AACA;;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAGA;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAHA;AACA;AACA;AAGA;;AAPA;;;;;AAUA;AAEA;AACA;;;;AACA;;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;;;;AACA;AAEA;;;;;AACA;;AACA;AAaA;AAOA;AAiBA;;;AApCA;;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AACA;AAGA;;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAGA;AACA;AACA;;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;A","sourceRoot":""}